"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Assert = require("assert");
const RateLimitQueue_1 = require("./RateLimitQueue");
function one() {
    return new Promise(function (resolve, reject) {
        setTimeout(() => resolve(["1", "2", "3"]), 10);
    });
}
function two(name) {
    return Promise.resolve("Hello " + name);
}
function getRand() {
    return Math.random() * 100;
}
describe("LimitingQueue", () => {
    it("Should limit correctly without capping", () => __awaiter(this, void 0, void 0, function* () {
        const queue = new RateLimitQueue_1.RateLimitQueue(2, 1000);
        yield queue.limit(function () { return one(); });
        Assert.equal(queue.getItemCount(), 0);
        yield queue.limit(function () { return two("Max Mustermann"); });
        Assert.equal(queue.getItemCount(), 0);
    }));
    it("Should cap one call", () => __awaiter(this, void 0, void 0, function* () {
        const queue = new RateLimitQueue_1.RateLimitQueue(2, 100);
        yield queue.limit(function () { return one(); });
        Assert.equal(queue.getItemCount(), 0);
        yield queue.limit(function () { return two("Max Mustermann"); });
        queue.limit(function () { return one(); });
        Assert.equal(queue.getItemCount(), 1);
        yield new Promise((resolve, reject) => {
            setTimeout(() => {
                Assert.equal(queue.getItemCount(), 0);
                resolve();
            }, 101);
        });
    }));
    it("Should work with non-promise returning function", () => __awaiter(this, void 0, void 0, function* () {
        const queue = new RateLimitQueue_1.RateLimitQueue(2, 1000);
        yield queue.limit(function () { return getRand(); });
        Assert.equal(queue.getItemCount(), 0);
        queue.limit(function () { return getRand(); });
        Assert.equal(queue.getItemCount(), 0);
    }));
});
//# sourceMappingURL=RateLimitQueue.spec.js.map